---
title: "HW: ISA tradeoff explorations with benchmarks"
...

In this homework, we'll extend our investigations in lab to examine code generated
by compilers to further look at tradeoffs in ISA design.

To aid in this, we've supplied a suite of benchmark programs and a suite of utilities
that count things in assembly files or disassembly output. (You could certainly write
your own versions of these utilities --- they are just searching text for particular
patterns.)


# The benchmarks

*  `queens.c`

# How many registers can a compiler effectively use?

Since a larger register file is slower than a smaller one, providing extra registers will slow down
programs unless they make effective use of these registers.

Although exactly how a compiler decides what and how many registers to use is a topic we won't cover in detail
in this class, we can explore this by examining how compiler output changes when the number of registers
it can use is restricted. To do this, we can examine the assembly generated by a compiler configured to
make variable numbers of registers available. In GCC, we can reduce the number of registers available
by using a command-line option like `-ffixed-r10`. When `-ffixed-r10` is specified, GCC assumes that `r10`
cannot be used by its generated code (even temporarily) and so will not use it.

(A more flexible way to do this experiment would be to define a new ISA for GCC which is like X86-64 but
with a different number of registers. This would allow us to experiment with adding registers in addition to
removing them, but would require us to recompile GCC, which would be too inconvenient for this assignment.)

To assist in this, we've supplied a program TBA that will examine an .o or executable file and count:

*  the number of registers each function uses
*  the number of instructions each function contains
*  the number of instructions that access memory each function contains
*  the number of register-to-register move instructions (for the next part)

Complete the table below for the benchmark programs TBA by comparing how GCC behaves with

# Number of operands

A major concern with including only two-operand instructions is that compilers will need to
generate a lot of register-to-register move instructions that would be unnecessary if
the three-argument form was supported.
Examine the suite of benchmark programs you examined for the previous part with the program.

Suppose we needed about 4 extra bits (the number bits neeeded to encode an x86-64 register number)
for each instruction to accomodate three-argument form. If so, about how much space would be
added or saved for each of the benchmark program by switching to the four-argument form?

<!-- FIXME: something with instruction traces -->

